% Paper-ready Discussion and Future Work section (IEEE style).
% Drop this into your main IEEEtran document after the Results section.

\section{Discussion}
\label{sec:discussion}

\subsection{Interpretation of Results}
The presented evidence supports three core properties of the proposed design: (i) the authorization primitive is usable through the standard build pipeline (compile, link, and image generation), (ii) debug enablement is released only after an explicit authorization event, and (iii) the failure policy is fail-stop (halt-on-failure) with both execution and debug remaining disabled. Collectively, these properties establish that authorization is enforced \emph{at the device} and is not solely a host-side convention.

\subsection{Security Rationale and Expected Resistance}
The architecture targets a pragmatic embedded threat surface: unauthorized firmware replacement and invasive debugging after physical access. By implementing the reference key in protected non-volatile storage that is not accessible via ordinary memory transactions, the design reduces the feasibility of key extraction by untrusted firmware through standard load/store operations. Furthermore, coupling authorization to an ISA-visible trigger integrates the policy into the execution model: authorization is invoked explicitly and can be located and audited in compiled artifacts, which is advantageous in engineering workflows where reproducibility and traceability are required.

\subsection{Fail-Stop Enforcement (Halt-on-Failure)}
Selecting halt-on-failure provides a conservative security posture. In particular, the fail-stop policy prevents the system from progressing into a partially-initialized state after a failed authorization attempt and reduces the opportunity for iterative online probing within a single boot session. From an engineering standpoint, fail-stop also simplifies state reasoning: the security FSM transitions either to an \emph{authorized} mode that releases both gates, or to an absorbing halt state that releases none.

\subsection{Trusted Computing Base Considerations}
The design shifts part of the security argument from purely runtime checks to the combined behavior of hardware enforcement and the software/toolchain pipeline. Because the authorization trigger is intended to be emitted deterministically by the toolchain, the toolchain and programming workflow become security-relevant artifacts. In practice, this motivates hardening and controlling distribution of the compiler/toolchain, and recording build provenance (e.g., toolchain version and policy) as part of the programming audit trail.

\subsection{Operationalization: Provisioning and Policy}
The security guarantees depend on correct provisioning of the reference key (or derived verifier) into protected storage and consistent host-side binding policy. The operational workflow benefits from centralized records and log tracking, which support accountability and can assist incident investigation. For deployment beyond a laboratory setting, the binding policy must be complemented with explicit lifecycle procedures (enrollment, administrative recovery, and decommissioning).

\section{Future Work}
\label{sec:futurework}

\subsection{Cryptographic Protocol Refinement}
Future work should formalize the authorization exchange as a standard cryptographic protocol (e.g., nonce-based challenge--response) and bind authorization tokens to a device-unique identity. This would strengthen resistance to replay and improve interoperability with established secure-boot and attestation ecosystems.

\subsection{Key Lifecycle Management}
An operational system requires key rotation and endpoint revocation. Adding explicit rotation epochs, revocation lists, and administrative recovery procedures would enable continued security under host compromise and credential expiration.

\subsection{Anti-Replay and Attempt Limiting Across Resets}
While fail-stop constrains repeated attempts per boot session, repeated reset-based attempts remain possible in principle. Persisting attempt counters in protected state, adding exponential backoff, and requiring fresh nonces from the device can raise the cost of brute-force or replay-driven attempts.

\subsection{Formal Methods and Assurance}
Because the Authenticator FSM is security-critical, future work should apply formal verification to prove safety properties (e.g., unauthorized paths never assert \texttt{exec\_enable} or \texttt{debug\_enable}) and to validate that failure states are absorbing under the specified policy.

\subsection{Overhead Characterization}
The current evaluation focuses on functional correctness. A follow-on study should quantify overhead, including verification latency (impact on boot time), hardware area/power of the compare path, and any code-size impact introduced by toolchain integration.

\subsection{Policy Generalization}
The same authorization primitive can be extended to gate additional privileged operations (e.g., firmware update mode, privileged peripheral configuration, secure memory region access). This would generalize the mechanism from debug-only control to a broader platform authorization framework.

